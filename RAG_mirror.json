[
    {
        "lemma": "Context: Global\nproposition height_mono_l:\n: \"height r \\<le> height l \\<Longrightarrow> height l < height l' \\<Longrightarrow> \n                            height (Node l e r) < height (Node l' e r)\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\n(* Proof *)\nby (induction l; simp)"
    },
    {
        "lemma": "Context: Global\nproposition height_mono_r:\n: \"height l \\<le> height r \\<Longrightarrow> height r < height r' \\<Longrightarrow>\n                            height (Node l e r) < height (Node l e r')\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\n(* Proof *)\nby (induction r; simp)\n\nprimrec longest:: \"'a tree \\<Rightarrow> ('a list) set\" where\n  \"longest Tip = {[]}\"\n| \"longest (Node l e r) = { e # p | p. p \\<in> (if height l > height r then longest l else if height r > height l then longest r else longest l \\<union> longest r)}\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\""
    },
    {
        "lemma": "Context: Global\nlemma check_weaken_distance:\n:\n  assumes \"check n (Suc x) t\"\n    shows \"check n x t\"\nusing assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nby (induction rule: check.induct, auto)"
    },
    {
        "lemma": "Context: Global\nproposition check_weaken_depth:\n:\n  assumes \"check (Suc x) d t\"\n  shows \"check x d t\"\nusing assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nby (induction rule: check.induct, auto)"
    },
    {
        "lemma": "Context: Global\nlemma common_prefix:\n:\n  \"\\<forall>p p'. check n d t \\<and> p\\<in>longest t \\<and> p'\\<in>longest t \\<longrightarrow> take n p = take n p'\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nprimrec longest:: \"'a tree \\<Rightarrow> ('a list) set\" where\n  \"longest Tip = {[]}\"\n| \"longest (Node l e r) = { e # p | p. p \\<in> (if height l > height r then longest l else if height r > height l then longest r else longest l \\<union> longest r)}\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nproof (induction rule: check.induct[of \"\\<lambda>n d t. \\<forall>p p'.\n       check n d t \\<and> p \\<in> longest t \\<and> p' \\<in> longest t \\<longrightarrow> take n p = take n p'\"])\n  case (1 d t)\n  then show ?case by simp\nnext\n  case (2 n d)\n  then show ?case by simp\nnext\n  case (3 n d l e r)\n  show ?case\n  proof (rule+, (erule conjE)+)\n    fix p p'\n    assume a1: \"check (Suc n) d (Node l e r)\"\n       and a2: \"p \\<in> longest (Node l e r)\"\n       and a3: \"p' \\<in> longest (Node l e r)\"\n    from a1 consider (1) \"d < height l - height r \\<and> check n d l\" | (2) \"d < height r - height l \\<and> check n d r\" by auto\n    then show \"take (Suc n) p = take (Suc n) p'\"\n    proof cases\n      case 1\n      then have \"height r < height l\" by auto\n      then have \"tl p \\<in> longest l\" and \"tl p' \\<in> longest l\" using a2 a3 by auto\n      then have \"take n (tl p) = take n (tl p')\" using 1 3 by blast\n      moreover have \"take (Suc n) p = hd p # take n (tl p)\" using a2 by auto\n      moreover have \"take (Suc n) p' = hd p' # take n (tl p')\" using a3 by auto\n      moreover have \"hd p = hd p'\" using a2 a3 by auto\n      ultimately show ?thesis by simp\n    next\n      case 2 (*symmetric*)\n      then have \"height l < height r\" by auto\n      then have \"tl p \\<in> longest r\" and \"tl p' \\<in> longest r\" using a2 a3 by auto\n      then have \"take n (tl p) = take n (tl p')\" using 2 3 by blast\n      moreover have \"take (Suc n) p = hd p # take n (tl p)\" using a2 by auto\n      moreover have \"take (Suc n) p' = hd p' # take n (tl p')\" using a3 by auto\n      moreover have \"hd p = hd p'\" using a2 a3 by auto\n      ultimately show ?thesis by simp\n    qed\n  qed\nqed\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\""
    },
    {
        "lemma": "Context: Global\nlemma count_true_base:\n[simp]:\n  \"count True [] = 0\" unfolding count_def",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp"
    },
    {
        "lemma": "Context: Global\nlemma count_false_base:\n[simp]:\n  \"count False [] = 0\" unfolding count_def",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp"
    },
    {
        "lemma": "Context: Global\nlemma count_honest_true_ind:\n[simp]:\n  assumes \"Honest e\"\n    shows \"count True (e#es) = Suc (count True es)\" unfolding count_def using assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp"
    },
    {
        "lemma": "Context: Global\nlemma count_honest_false_ind:\n[simp]:\n  assumes \"Honest e\"\n    shows \"count False (e#es) = count False es\" unfolding count_def using assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp"
    },
    {
        "lemma": "Context: Global\nlemma count_dhonest_false_ind:\n[simp]:\n  assumes \"\\<not> Honest e\"\n  shows \"count False (e#es) = Suc (count False es)\" unfolding count_def using assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp"
    },
    {
        "lemma": "Context: Global\nlemma count_dhonest_true_ind:\n[simp]:\n  assumes \"\\<not> Honest e\"\n  shows \"count True (e#es) = count True es\" unfolding count_def using assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby simp\n\nlocale mining =\n    fixes add :: \"'a tree \\<Rightarrow> 'a tree\"\n    assumes m1: \"\\<exists>e. add Tip = Node Tip e Tip\"\n        and m2: \"\\<And>l e r. add (Node l e r) = Node (add l) e r \\<or> add (Node l e r) = Node l e (add r)\"\nbegin"
    },
    {
        "lemma": "Context: mining\nlemma mining_cases:\n:\n    fixes l e r\n    obtains (l) \"add (Node l e r) = Node (add l) e r\"\n          | (r) \"add (Node l e r) = Node l e (add r)\"\n    using m2",
        "proof": "by auto"
    },
    {
        "lemma": "Context: mining\nlemma height_add:\n:\"height (add t) = height t \\<or> height (add t) = Suc (height t)\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\n(* Proof *)\nproof (induction t)\n    case Tip\n    then show ?case using m1 by auto\n  next\n    case (Node l e r)\n    show ?case\n    proof (cases rule: mining_cases[of l e r])\n      case l\n      moreover from this have \"height (add (Node l e r)) = height (Node (add l) e r)\" by simp\n      ultimately show ?thesis using Node(1) by auto\n    next\n      case r\n      moreover from this have \"height (add (Node l e r)) = height (Node l e (add r))\" by simp\n      ultimately show ?thesis using Node(2) by auto\n    qed\n  qed"
    },
    {
        "lemma": "Context: mining\nlemma check_add:\n:\n\"check n (Suc d) t \\<longrightarrow> (height t < height (add t) \\<and> check n (Suc (Suc d)) (add t)) \\<or> \n                       (height t = height (add t) \\<and> check n (Suc d) (add t)) \\<or> \n                       (height t = height (add t) \\<and> check n d (add t))\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nproof (induction rule: check.induct[of \"\\<lambda>n d t. check n (Suc d) t \\<longrightarrow> height t < height (add t) \\<and> check n (Suc (Suc d)) (add t) \\<or> height t = height (add t) \\<and> check n (Suc d) (add t) \\<or> height t = height (add t) \\<and> check n d (add t)\"])\n    case (1 d t)\n    then show ?case using height_add[of t] by auto\n  next\n    case (2 n d)\n    then show ?case by simp\n  next\n    case (3 n d l e r)\n    show ?case\n    proof\n      assume \"check (Suc n) (Suc d) (Node l e r)\"\n      then consider (l) \"Suc d < height l - height r \\<and> check n (Suc d) l\" | (r) \"Suc d < height r - height l \\<and> check n (Suc d) r\" by auto\n      then show \"height (Node l e r) < height (add (Node l e r)) \\<and> check (Suc n) (Suc (Suc d)) (add (Node l e r)) \\<or>\n      height (Node l e r) = height (add (Node l e r)) \\<and> check (Suc n) (Suc d) (add (Node l e r)) \\<or>\n      height (Node l e r) = height (add (Node l e r)) \\<and> check (Suc n) d (add (Node l e r))\"\n      proof (cases)\n        case l\n        then consider \"height l < height (add l) \\<and> check n (Suc (Suc d)) (add l)\" | \"height l = height (add l) \\<and> check n (Suc d) (add l)\" | \"height l = height (add l) \\<and> check n d (add l)\" using 3 by auto\n        then show ?thesis\n        proof cases\n          case 1\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            moreover have \"check (Suc n) (Suc (Suc d)) (Node (add l) e r)\" using 1 l by auto\n            moreover have \"height (Node l e r) < height (add (Node l e r))\" using 1 l l2 by auto\n            ultimately show ?thesis by simp\n          next\n            case r\n            consider \"height (add r) = height r\" | \"height (add r) = Suc (height r)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using l l1 r by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2\n              moreover have \"height l > Suc (height r)\" using l by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height l - height (add r)\" using x l by auto\n                moreover have \"check n d l\" using l check_weaken_distance[of n d l] by simp\n                ultimately show ?thesis using r by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          qed\n        next\n          case 2 (*symmetric to case 1*)\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            moreover have \"check (Suc n) (Suc d) (Node (add l) e r)\" using 2 l by auto\n            moreover have \"height (Node l e r) = height (add (Node l e r))\" using 2 l2 by auto\n            ultimately show ?thesis by simp\n          next\n            case r\n            consider \"height (add r) = height r\" | \"height (add r) = Suc (height r)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using l l1 r by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2\n              moreover have \"height l > Suc (height r)\" using l by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height l - height (add r)\" using x l by auto\n                moreover have \"check n d l\" using l check_weaken_distance[of n d l] by simp\n                ultimately show ?thesis using r by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          qed\n        next\n          case 3 (*symmetric to case 2*)\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            moreover have \"check (Suc n) d (Node (add l) e r)\" using 3 l by auto\n            moreover have \"height (Node l e r) = height (add (Node l e r))\" using 3 l2 by auto\n            ultimately show ?thesis by simp\n          next\n            case r\n            consider \"height (add r) = height r\" | \"height (add r) = Suc (height r)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using l l1 r by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2\n              moreover have \"height l > Suc (height r)\" using l by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using r by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height l - height (add r)\" using x l by auto\n                moreover have \"check n d l\" using l check_weaken_distance[of n d l] by simp\n                ultimately show ?thesis using r by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          qed\n        qed\n      next\n        case r (*symmetric to l case*)\n        then consider \"height r < height (add r) \\<and> check n (Suc (Suc d)) (add r)\" | \"height r = height (add r) \\<and> check n (Suc d) (add r)\" | \"height r = height (add r) \\<and> check n d (add r)\" using 3 by auto\n        then show ?thesis\n        proof cases\n          case 1\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            consider \"height (add l) = height l\" | \"height (add l) = Suc (height l)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using l1 l2 r by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2\n              moreover have \"height r > Suc (height l)\" using r by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height r - height (add l)\" using x r by auto\n                moreover have \"check n d r\" using r check_weaken_distance[of n d r] by simp\n                ultimately show ?thesis using l2 by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          next\n            case r2:r\n            moreover have \"check (Suc n) (Suc (Suc d)) (Node l e (add r))\" using 1 r by auto\n            moreover have \"height (Node l e r) < height (add (Node l e r))\" using 1 r r2 by auto\n            ultimately show ?thesis by simp\n          qed\n        next\n          case 2\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            consider \"height (add l) = height l\" | \"height (add l) = Suc (height l)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using l2 l1 r by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2 (*symmetric to 1*)\n              moreover have \"height r > Suc (height l)\" using r by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height r - height (add l)\" using x r by auto\n                moreover have \"check n d r\" using r check_weaken_distance[of n d r] by simp\n                ultimately show ?thesis using l2 by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          next\n            case r2: r\n            moreover have \"check (Suc n) (Suc d) (Node l e (add r))\" using 2 r by auto\n            moreover have \"height (Node l e r) = height (add (Node l e r))\" using 2 r2 by auto\n            ultimately show ?thesis by simp\n          qed\n        next\n          case 3 (*symmetric to 2*)\n          then show ?thesis\n          proof (cases rule: mining_cases[of l e r])\n            case l2: l\n            consider \"height (add l) = height l\" | \"height (add l) = Suc (height l)\" using height_add by auto\n            then show ?thesis\n            proof cases\n              case l1: 1\n              then have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) (Suc d) (add (Node l e r))\" using r l1 l2 by auto\n              ultimately show ?thesis by simp\n            next\n              case x: 2\n              moreover have \"height r > Suc (height l)\" using r by auto\n              ultimately have \"height (Node l e r) = height (add (Node l e r))\" using l2 by simp\n              moreover have \"check (Suc n) d (add (Node l e r))\"\n              proof -\n                have \"d < height r - height (add l)\" using x r by auto\n                moreover have \"check n d r\" using r check_weaken_distance[of n d r] by simp\n                ultimately show ?thesis using l2 by simp\n              qed\n              ultimately show ?thesis by simp\n            qed\n          next\n            case r2: r\n            moreover have \"check (Suc n) d (Node l e (add r))\" using 3 r by auto\n            moreover have \"height (Node l e r) = height (add (Node l e r))\" using 3 r2 by auto\n            ultimately show ?thesis by simp\n          qed\n        qed\n      qed\n    qed\n  qed"
    },
    {
        "lemma": "Context: mining\ncorollary check_add_cases:\n:\n    assumes \"check n (Suc d) t\"\n    obtains \"check n (Suc (Suc d)) (add t)\" | \"check n (Suc d) (add t)\" | \"check n d (add t)\"\n    using assms check_add",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nby blast\nend\n\nlocale honest = mining +\n  assumes h1: \"\\<And>l e r. height l \\<ge> height r \\<and> add (Node l e r) = Node (add l) e r \\<or> \n                       height r \\<ge> height l \\<and> add (Node l e r) = Node l e (add r)\"\nbegin"
    },
    {
        "lemma": "Context: Global\nlemma mining_cases:\n:\n  fixes l e r\n  obtains (l) \"height l \\<ge> height r \\<and> add (Node l e r) = Node (add l) e r\"\n        | (r) \"height r \\<ge> height l \\<and> add (Node l e r) = Node l e (add r)\"\n  using h1",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\n(* Proof *)\nby auto"
    },
    {
        "lemma": "Context: Global\nlemma height_add:\n: \"height (add t) = Suc (height t)\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\n(* Proof *)\nproof (induction t)\n  case Tip\n  then show ?case using m1 by auto\nnext\n  case (Node l e r)\n  show ?case\n  proof (cases rule: mining_cases[of r l e])\n    case l\n    moreover from this have \"height (add (Node l e r)) = height (Node (add l) e r)\" by simp\n    ultimately show ?thesis using Node(1) by simp\n  next\n    case r\n    moreover from this have \"height (add (Node l e r)) = height (Node l e (add r))\" by simp\n    ultimately show ?thesis using Node(2) by simp\n  qed\nqed"
    },
    {
        "lemma": "Context: Global\nlemma check_add:\n[rule_format]:\n  \"check n depth t \\<longrightarrow> check n (Suc depth) (add t)\"",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\n(* Proof *)\nproof (induction rule: check.induct[of \"\\<lambda>n d t. check n d t \\<longrightarrow> check n (Suc d) (add t)\"])\n  case (1 d t)\n  then show ?case by simp\nnext\n  case (2 n d)\n  then show ?case by simp\nnext\n  case (3 n d l e r)\n  show ?case\n  proof\n    assume \"check (Suc n) d (Node l e r)\"\n    then consider \"d < height l - height r \\<and> check n d l\" | \"d < height r - height l \\<and> check n d r\" by auto\n    then show \"check (Suc n) (Suc d) (add (Node l e r))\"\n    proof cases\n      case 1\n      then have \"add (Node l e r) = Node (add l) e r\" using h1 by fastforce\n      moreover have \"check (Suc n) (Suc d) (Node (add l) e r)\"\n      proof -\n        from 1 have \"Suc d < height (add l) - height r\" using height_add by auto\n        moreover have \"check n (Suc d) (add l)\" using 1 3 by simp\n        ultimately show ?thesis by simp\n      qed\n      ultimately show ?thesis by simp\n    next\n      case 2\n      then have \"add (Node l e r) = Node l e (add r)\" using h1 by force\n      moreover have \"check (Suc n) (Suc d) (Node l e (add r))\"\n      proof -\n        from 2 have \"Suc d < height (add r) - height l\" using height_add by auto\n        moreover have \"check n (Suc d) (add r)\" using 2 3 by simp\n        ultimately show ?thesis by simp\n      qed\n      ultimately show ?thesis by simp\n    qed\n  qed\nqed\n\nend\n\nlocale blockchain =\n  honest hadd + mining dadd\n  for hadd::\"'a tree \\<Rightarrow> 'a tree\" and dadd::\"'a tree \\<Rightarrow> 'a tree\" +\n  fixes depth::nat\n    and t0::\"'a tree\"\n  assumes b1: \"check depth (Suc (height t0 - depth)) t0\"\n      and b2: \"height t0 > depth\"\nbegin\n\ninductive_set traces :: \"('a event list) set\" where\n  honest_base: \"[\\<lparr>Honest = True, State = hadd t0\\<rparr>] \\<in> traces\"\n| dishonest_base: \"[\\<lparr>Honest = False, State = dadd t0\\<rparr>] \\<in> traces\"\n| honest_induct: \"\\<lbrakk>t \\<in> traces\\<rbrakk> \\<Longrightarrow> \\<lparr>Honest = True, State = hadd (State (hd t))\\<rparr> # t \\<in> traces\"\n| dishonest_induct: \"\\<lbrakk>t \\<in> traces; count False t < count True t + (height t0 - depth)\\<rbrakk> \\<Longrightarrow> \n                     \\<lparr>Honest = False, State = dadd (State (hd t))\\<rparr> # t \\<in> traces\""
    },
    {
        "lemma": "Context: blockchain\nlemma bounded_dishonest_mining:\n:\n  fixes t\n  assumes \"t \\<in> traces\"\n  shows \"count True t + (height t0 - depth) \\<ge> count False t\"\n  using assms\n  using b2",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby (induction rule:traces.induct; simp)"
    },
    {
        "lemma": "Context: blockchain\nlemma bounded_check:\n:\n  fixes t\n  assumes \"t \\<in> traces\"\n  shows \"check depth (Suc (count True t + (height t0 - depth) - count False t)) (State (hd t))\"\n  using assms",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nfun check :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n  \"check 0 d t = True\"\n| \"check (Suc n) d Tip = False\"\n| \"check (Suc n) d (Node l e r) =\n    (\n    ( (height l - height r > d) \\<and> (check n d l) ) \\<or>\n    ( (height r - height l > d) \\<and> (check n d r) )\n    )\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nproof (induction rule:traces.induct)\n  case honest_base\n  define t where \"t = [\\<lparr>Honest = True, State = hadd t0\\<rparr>]\"\n  then have \"Suc (count True t + (height t0 - depth) - count False t) = Suc (Suc (height t0 - depth))\" by simp\n  moreover from b1 have \"check depth (Suc (Suc (height t0 - depth))) (hadd t0)\" using honest.check_add[of hadd depth \"Suc (height t0 - depth)\" t0] by (simp add: honest_axioms)\n  ultimately show ?case unfolding t_def by simp\nnext\n  case dishonest_base\n  define t where \"t = [\\<lparr>Honest = False, State = dadd t0\\<rparr>]\"\n  then have *: \"Suc (count True t + (height t0 - depth) - count False t) = (height t0 - depth)\" using b2 by simp\n  \n  show ?case\n  proof (cases rule: check_add_cases[OF b1])\n    case 1\n    then have \"check depth (Suc (height t0 - depth)) (dadd t0)\" using * unfolding t_def using check_weaken_distance by simp\n    then show ?thesis using * unfolding t_def using check_weaken_distance by simp\n  next\n    case 2\n    then show ?thesis using * unfolding t_def using check_weaken_distance by auto\n  next\n    case 3\n    then show ?thesis using * unfolding t_def by simp\n  qed\nnext\n  case (honest_induct t)\n  define t' where \"t' = \\<lparr>Honest = True, State = hadd (State (hd t))\\<rparr> # t\"\n  moreover have \"Suc (count True t + (height t0 - depth)) > count False t\" using honest_induct bounded_dishonest_mining[OF honest_induct(1)] by simp\n  ultimately have \"count True t' + (height t0 - depth) - count False t' = Suc (count True t + (height t0 - depth) - count False t)\" by simp\n  moreover from honest_induct have \"check depth (Suc (Suc (count True t + (height t0 - depth) - count False t))) (hadd (State (hd t)))\" using honest.check_add[OF honest_axioms, of depth \"Suc (count True t + (height t0 - depth) - count False t)\" \"(State (hd t))\"] by (simp add: honest_axioms)\n  ultimately show ?case unfolding t'_def using check_weaken_distance[of depth \"Suc (count True t + (height t0 - depth) - count False t)\" \"hadd (State (hd t))\"] by simp\nnext\n  case (dishonest_induct t)\n  define t' where \"t' = \\<lparr>Honest = False, State = dadd (State (hd t))\\<rparr> # t\"\n  then have *: \"count True t' + (height t0 - depth) - count False t' = count True t + (height t0 - depth) - Suc (count False t)\" by simp\n\n  have \"check depth (Suc (count True t' + (height t0 - depth) - count False t')) (State (hd t'))\"\n  proof (cases rule: check_add_cases[OF dishonest_induct(3)])\n    case 1\n    then have \"check depth (Suc ((count True t + (height t0 - depth) - (count False t)))) (dadd (State (hd t)))\" using check_weaken_distance[of depth \"(Suc (count True t + (height t0 - depth)- count False t))\" \"(dadd (State (hd t)))\"] by simp\n    then have \"check depth (((count True t + (height t0 - depth) - (count False t)))) (dadd (State (hd t)))\" using check_weaken_distance[of depth \"(count True t + (height t0 - depth)- count False t)\" \"(dadd (State (hd t)))\"] by simp\n    moreover have \"count True t + (height t0 - depth) > (count False t)\" using dishonest_induct(2) by simp\n    ultimately have \"check depth (Suc (count True t + (height t0 - depth) - Suc (count False t))) (dadd (State (hd t)))\" using Suc_diff_Suc by simp\n    then show ?thesis using * unfolding t'_def by simp\n  next\n    case 2\n    then have \"check depth (((count True t + (height t0 - depth) - (count False t)))) (dadd (State (hd t)))\" using check_weaken_distance[of depth \"(count True t + (height t0 - depth)- count False t)\" \"(dadd (State (hd t)))\"] by simp\n    moreover have \"count True t + (height t0 - depth) > (count False t)\" using dishonest_induct(2) by simp\n    ultimately have \"check depth (Suc (count True t + (height t0 - depth) - Suc (count False t))) (dadd (State (hd t)))\" using Suc_diff_Suc by simp\n    then show ?thesis using * unfolding t'_def by simp\n  next\n    case 3\n    moreover have \"count True t + (height t0 - depth) > (count False t)\" using dishonest_induct(2) by simp\n    ultimately have \"check depth (Suc (count True t + (height t0 - depth) - Suc (count False t))) (dadd (State (hd t)))\" using Suc_diff_Suc by simp\n    then show ?thesis using * unfolding t'_def by simp\n  qed\n  then show ?case unfolding t'_def by simp\nqed"
    },
    {
        "lemma": "Context: blockchain\ntheorem consensus:\n:\n  fixes t\n  assumes \"t \\<in> traces\"\n  and \"p \\<in> longest (State (hd t))\"\n  and \"p' \\<in> longest (State (hd t))\"\nshows \"take depth p = take depth p'\"\nusing assms(2,3) common_prefix[of depth \"Suc (count True t + (height t0 - depth) - count False t)\" \"(State (hd t))\"] bounded_check[OF assms(1)]",
        "proof": "(* Recursive Context *)\ndatatype 'a tree =\n    Tip\n  | Node \"'a tree\" 'a \"'a tree\"\n\nprimrec height :: \"'a tree \\<Rightarrow> nat\" where\n  \"height Tip = 0\"\n| \"height (Node l e r) = Suc (max (height l) (height r))\"\n\nprimrec longest:: \"'a tree \\<Rightarrow> ('a list) set\" where\n  \"longest Tip = {[]}\"\n| \"longest (Node l e r) = { e # p | p. p \\<in> (if height l > height r then longest l else if height r > height l then longest r else longest l \\<union> longest r)}\"\n\nrecord 'a event =\n  Honest :: bool\n  State :: \"'a tree\"\n\ndefinition count::\"bool \\<Rightarrow> ('a event) list \\<Rightarrow> nat\" where\n  \"count b = List.length \\<circ> filter (\\<lambda>x. Honest x = b)\"\n\n(* Proof *)\nby blast\nend\n\nend"
    },
    {
        "lemma": "lemma obtainmax:\n  assumes \"ts \\<noteq> []\"\n  shows \"\\<exists>t' \\<in> set ts. \\<forall>t'' \\<in> set ts - {t'}. nHeight t'' \\<le> nHeight t'\"",
        "proof": "(* Recursive Context *)\ndatatype 'a nTree =\n  nNode 'a \"'a nTree list\"\n\nfun nHeight :: \"'a nTree \\<Rightarrow> nat\" where\n  \"nHeight (nNode x []) = 1\"\n| \"nHeight (nNode x (t # ts)) = Suc (foldr max (map nHeight (t # ts)) 0)\"\n\n(* Proof *)\nproof -\n  let ?S = \"set (map nHeight ts)\"\n  have \"?S \\<noteq> {}\" using assms by auto\n  moreover have \"finite ?S\" by simp\n  ultimately have \"Max ?S \\<in> ?S\" using Max_in by blast\n  then obtain t' where \"t' \\<in> set ts\" and max_height: \"nHeight t' = Max ?S\"\n    by (smt (verit, ccfv_threshold) image_iff list.set_map)\n  then have \"\\<forall>t'' \\<in> set ts. nHeight t'' \\<le> nHeight t'\"\n    using Max_ge \\<open>finite ?S\\<close> \\<open>?S \\<noteq> {}\\<close> max_height by auto\n  then show ?thesis using \\<open>t' \\<in> set ts\\<close> by auto\nqed"
    },
    {
        "lemma": "lemma foldr_max_eq:\n  assumes \"t' \\<in> set ts\" \n    and \"\\<forall>t'' \\<in> set ts - {t'}. nHeight t'' \\<le> nHeight t'\"\n  shows \"foldr max (map nHeight ts) 0 = nHeight t'\"",
        "proof": "(* Recursive Context *)\ndatatype 'a nTree =\n  nNode 'a \"'a nTree list\"\n\nfun nHeight :: \"'a nTree \\<Rightarrow> nat\" where\n  \"nHeight (nNode x []) = 1\"\n| \"nHeight (nNode x (t # ts)) = Suc (foldr max (map nHeight (t # ts)) 0)\"\n\n(* Proof *)\nlemma foldr_max_eq:\n  assumes \"t' \\<in> set ts\" \n    and \"\\<forall>t'' \\<in> set ts - {t'}. nHeight t'' \\<le> nHeight t'\"\n  shows \"foldr max (map nHeight ts) 0 = nHeight t'\"\n  using assms\nproof (induct ts)\n  case Nil\n  then show ?case by simp\nnext\n  case (Cons y ys)\n  show ?case\n  proof (cases \"y = t'\")\n    case True\n    then have \"\\<forall>t'' \\<in> set ys. nHeight t'' \\<le> nHeight t'\"\n      using Cons.prems by auto\n    then have \"foldr max (map nHeight ys) 0 \\<le> nHeight t'\"\n      by (induct ys) (auto simp: max_def)\n    then show ?thesis\n      using True by (simp add: max.absorb1)\n  next\n    case False\n    then have \"t' \\<in> set ys\" \n      using Cons.prems(1) by auto\n    then have \"foldr max (map nHeight ys) 0 = nHeight t'\"\n      using Cons.prems(2) False Cons.hyps by auto\n    moreover have \"nHeight y \\<le> nHeight t'\"\n      using Cons.prems False by auto\n    ultimately show ?thesis\n      by (simp add: max_absorb2)\n  qed\nqed"
    },
    {
        "lemma": "lemma branch_height:\n  assumes  \"p \\<in> set (nPaths t)\"\n  shows \"nHeight t \\<ge> length p\"",
        "proof": "(* Recursive Context *)\ndatatype 'a nTree =\n  nNode 'a \"'a nTree list\"\n\nfun nHeight :: \"'a nTree \\<Rightarrow> nat\" where\n  \"nHeight (nNode x []) = 1\"\n| \"nHeight (nNode x (t # ts)) = Suc (foldr max (map nHeight (t # ts)) 0)\"\n\nfun nPaths :: \"'a nTree \\<Rightarrow> 'a list list\" where\n\"nPaths (nNode x []) = [[x]]\"\n|\"nPaths (nNode x (t#ts)) = map (\\<lambda>p. x # p) (concat (map nPaths (t # ts)))\"\n\n(* Proof *)\nusing local.Cons by blast"
    }
]